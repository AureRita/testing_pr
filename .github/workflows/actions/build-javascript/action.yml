name: Install node modules
description: Install node modules in a defined folder and cache results
inputs:
  node_version:
    description: Node version
    required: true
  package_locks:
    description: JS packages.lock list
    required: true
  node_modules:
    description: Node modules folders list
    required: true
outputs:
  cache-hit:
    description: Indicate if node modules cache was restored
    value: ${{ steps.save-dependencies.outputs.cache-hit }}

runs:
  using: "composite"
  steps:
    # Reformat packages input into arrays of folders, build and install commands The arrays are exported in JSON format since we can't export arrays to output
    - name: Prepare action parameters
      id: action-parameters
      run: |
        # Build command only when the node modules cache is found
        buildCommandJson='['
        # Install plus build when the cache is not found
        installAndBuildCommandJson='['
        # Create array of lock files
        buildLocks=''

        IFS=$' \t\n'
        commaSeparator=''
        spaceSeparator=''
        while read -r package_lock; do
          if test -f "$package_lock"; then
            js_folder=$(echo $package_lock | sed s_/package-lock\.json__)
            package_json=$(echo $package_lock | sed s_package-lock\.json_package\.json_)

            # Create/remove the lock at the beginning/end of the process so its presence can be checked
            buildLocks+="$spaceSeparator$js_folder/buildLock"

            # Only build when the action is in the package.json, we create a buildLock file to check when the build is really finished
            # because sometimes the action switched to the next one while the build was not over
            if grep -q '"build":' "$package_json"; then
              buildCommandJson+="$commaSeparator\"(pushd $js_folder; touch buildLock; npm run build; rm buildLock; popd)\""
              installAndBuildCommandJson+="$commaSeparator\"(pushd $js_folder; touch buildLock; npm ci; npm run build; rm buildLock; popd)\""
            else
              # Create/remove the lock at the beginning/end of the process so its presence can be checked
              installAndBuildCommandJson+="$commaSeparator\"(pushd $js_folder; touch buildLock; npm ci; rm buildLock; popd)\""
            fi
            commaSeparator=', '
            spaceSeparator=' '
          fi
        done <<< "${{ inputs.package_locks }}"

        buildCommandJson+=']'
        installAndBuildCommandJson+=']'

        echo "build-command=$buildCommandJson" >> $GITHUB_OUTPUT
        echo "install-and-build-command=$installAndBuildCommandJson" >> $GITHUB_OUTPUT
        echo "build-locks=$buildLocks" >> $GITHUB_OUTPUT
      shell: bash

    # Always setup node to make sure you have the right version
    - name: Setup Node ${{ inputs.node_version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ inputs.node_version }}
        cache: 'npm'
        cache-dependency-path: ${{ inputs.package_locks }}

    # Try and restore cache if it exists, then build assets (we still run
    - name: Save dependencies
      id: save-dependencies
      uses: actions/cache@v3
      with:
        path: ${{ inputs.node_modules }}
        key: node-modules-${{ inputs.node_version }}-${{ hashFiles(inputs.package_locks) }}

    # If node_modules cache is hit simply build the assets
    - name: Build assets only (dependencies came from cache)
      if: steps.save-dependencies.outputs.cache-hit == 'true'
      run: ${{ join(fromJson(steps.action-parameters.outputs.build-command), ' & ') }}
      shell: bash

    # If the cache was not restored we install node_modules dependencies and then build the assets
    - name: Install dependencies and build assets
      if: steps.save-dependencies.outputs.cache-hit != 'true'
      run: ${{ join(fromJson(steps.action-parameters.outputs.install-and-build-command), ' & ') }}
      shell: bash

    # Wait for all builds to be finished (the check is required because we encountered cases where the action exited before
    # everything was built, probably because of the parallelization
    - name: Check that all builds are finished
      run: |
        echo Checking for all these lock files ${{ steps.action-parameters.outputs.build-locks }}
        for lockFile in ${{ steps.action-parameters.outputs.build-locks }}; do
          if [ -f $lockFile ]; then
            echo Wait for $lockFile to be removed
            sleep 1
            while [ -f $lockFile ]; do
              echo $lockFile still present wait a bit more
              sleep 1
            done
          fi
          echo $lockFile is no longer present
        done
      shell: bash
